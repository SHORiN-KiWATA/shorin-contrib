#!/bin/bash
# Description: 清理系统

# 【功能说明】
# 1. 移除孤儿软件包 (Orphans)
# 2. 清理 Pacman 软件包缓存 (保留安装包，删除旧版本)
# 3. 清理残留的下载目录 (download-*)
# 4. 清理 Systemd 日志 (只保留最近 2 周)
# 5. 清空用户回收站 (Trash) 和缩略图缓存 (Thumbnails)
# 6. 移除未使用的 Flatpak 运行时
# 7. 清理截图与录屏目录 (Screenshots & wf-recorder)
# 8. 清理旧 Btrfs 快照与 btrfs-assistant 的冗余备份子卷
set -euo pipefail
export SHELL="$(command -v bash || echo /bin/bash)"

# ===============================================================
# Arch Linux System Cleanup Assistant (Best Version)
# ===============================================================

# ------------------------------
# 1. Default parameters & KISS Language Detection
# ------------------------------
SKIP_CONFIRM=false

if [[ "${LC_MESSAGES:-${LANG:-}}" == *zh_CN* ]]; then
  UI_LANG="zh"
else
  UI_LANG="en"
fi

# ------------------------------
# 2. Argument parsing
# ------------------------------
usage() {
  cat <<EOF
Usage: $(basename "$0") [options]

Options:
  --ui-lang zh|en    Force UI language (default: auto)
  --yes, -y          Skip confirmation prompt (non-interactive)
  --help, -h         Show this help and exit
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
  --ui-lang) [[ "${2:-}" =~ ^(zh|en)$ ]] && UI_LANG="$2" && shift 2 || { echo "Error: --ui-lang requires zh or en."; exit 1; } ;;
  --yes | -y) SKIP_CONFIRM=true && shift ;;
  --help | -h) usage; exit 0 ;;
  *) echo "Unknown option: $1"; usage; exit 1 ;;
  esac
done

# ------------------------------
# 3. Localization Logic (Associative Arrays)
# ------------------------------
declare -A MSG
if [[ "$UI_LANG" == "zh" ]]; then
  TAG_INFO="[消息]"
  TAG_SUCCESS="[成功]"
  TAG_WARN="[注意]"
  TAG_ERROR="[错误]"

  MSG[INTRO_HEADER]="=== Arch Linux 系统清理助手 ==="
  MSG[DESC_TITLE]="本脚本将执行以下清理操作："
  MSG[DESC_1]="1. 删除孤儿软件包 (不再被需要的依赖)"
  MSG[DESC_2]="2. 清理软件包缓存 (仅保留已安装版本)"
  MSG[DESC_3]="3. 清理 systemd 日志 (保留最近2周)"
  MSG[DESC_4]="4. 清空回收站、缩略图和剪贴板缓存"
  MSG[DESC_5]="5. 删除未使用的 Flatpak 运行时"
  MSG[DESC_6]="6. 清理截图和屏幕录制文件"
  MSG[DESC_7]="7. 清理旧 Btrfs 快照与冗余备份子卷"
  MSG[ASK_CONFIRM]="是否继续执行清理？[Y/n]"
  MSG[ABORT]="用户已取消清理。"
  MSG[DONE]="系统清理完成！"

  MSG[NO_HELPER]="未找到 AUR 助手 (需要 paru 或 yay)"
  MSG[HELPER_USE]="使用 AUR 助手：%s"
  MSG[STEP_ORPHAN]="正在检查孤儿软件包..."
  MSG[ORPHAN_FOUND]="发现孤儿软件包，准备清理..."
  MSG[ORPHAN_CLEAN]="已删除孤儿软件包。"
  MSG[ORPHAN_NONE]="未发现孤儿软件包。"
  MSG[STEP_CACHE]="正在清理软件包缓存..."
  MSG[CACHE_DONE]="软件包缓存已清理。"
  MSG[STEP_BROKEN]="正在清理残留下载目录..."
  MSG[BROKEN_DONE]="残留目录已清理。"
  MSG[STEP_LOG]="正在清理 systemd 日志..."
  MSG[LOG_DONE]="系统日志已清理。"
  MSG[CLIP_DONE]="剪贴板缓存已清理。"
  MSG[STEP_TRASH]="正在清理回收站和缩略图..."
  MSG[TRASH_DONE]="回收站已清空。"
  MSG[THUMB_DONE]="缩略图已清理。"
  MSG[STEP_FLATPAK]="正在检查未使用的 Flatpak 运行时..."
  MSG[FLATPAK_DONE]="未使用的 Flatpak 运行时已删除。"
  MSG[STEP_MEDIA]="正在清理截图和屏幕录制文件..."
  MSG[MEDIA_DONE]="截图和录屏文件已清理。"

  MSG[STEP_SNAP]="正在清理超出配额的旧 Btrfs 快照..."
  MSG[SNAP_DONE]="旧快照已按配额清理。"
  MSG[STEP_BTRFS_BA]="正在检查 btrfs-assistant 冗余备份子卷..."
  MSG[BTRFS_BA_DONE]="冗余备份子卷已删除。"
  MSG[BTRFS_BA_NONE]="未发现冗余备份子卷。"
else
  TAG_INFO="[INFO]"
  TAG_SUCCESS="[OK]"
  TAG_WARN="[WARN]"
  TAG_ERROR="[ERROR]"

  MSG[INTRO_HEADER]="=== Arch Linux System Cleanup Assistant ==="
  MSG[DESC_TITLE]="The script will perform the following tasks:"
  MSG[DESC_1]="1. Remove orphaned packages"
  MSG[DESC_2]="2. Clean package cache (keep installed)"
  MSG[DESC_3]="3. Vacuum systemd journal logs (keep 2 weeks)"
  MSG[DESC_4]="4. Empty Trash, thumbnail and clipboard cache"
  MSG[DESC_5]="5. Remove unused Flatpak runtimes"
  MSG[DESC_6]="6. Clean screenshots and screen records"
  MSG[DESC_7]="7. Clean old btrfs snapshots & backup subvols"
  MSG[ASK_CONFIRM]="Continue with cleanup? [Y/n]"
  MSG[ABORT]="Cleanup cancelled by user."
  MSG[DONE]="System cleanup completed!"

  MSG[NO_HELPER]="No AUR helper found (paru or yay required)."
  MSG[HELPER_USE]="Using AUR helper: %s"
  MSG[STEP_ORPHAN]="Checking for orphaned packages..."
  MSG[ORPHAN_FOUND]="Orphaned packages detected, cleaning..."
  MSG[ORPHAN_CLEAN]="Orphaned packages removed."
  MSG[ORPHAN_NONE]="No orphaned packages found."
  MSG[STEP_CACHE]="Cleaning package cache..."
  MSG[CACHE_DONE]="Package cache cleaned."
  MSG[STEP_BROKEN]="Cleaning residual download directories..."
  MSG[BROKEN_DONE]="Residual directories removed."
  MSG[STEP_LOG]="Vacuuming systemd journal logs..."
  MSG[LOG_DONE]="Systemd journal logs cleaned."
  MSG[CLIP_DONE]="Clipboard cache cleaned."
  MSG[STEP_TRASH]="Cleaning user Trash and thumbnails..."
  MSG[TRASH_DONE]="Trash emptied."
  MSG[THUMB_DONE]="Thumbnails cleaned."
  MSG[STEP_FLATPAK]="Checking for unused Flatpak runtimes..."
  MSG[FLATPAK_DONE]="Unused Flatpak runtimes removed."
  MSG[STEP_MEDIA]="Cleaning screenshots and screen records..."
  MSG[MEDIA_DONE]="Screenshots and screen records cleaned."

  MSG[STEP_SNAP]="Cleaning old btrfs snapshots..."
  MSG[SNAP_DONE]="Old snapshots cleaned."
  MSG[STEP_BTRFS_BA]="Checking btrfs-assistant backup subvolumes..."
  MSG[BTRFS_BA_DONE]="Backup subvolumes cleaned."
  MSG[BTRFS_BA_NONE]="No redundant backup subvolumes found."
fi

# ------------------------------
# 4. Define Colors & Logging
# ------------------------------
NC='\033[0m'
H_BLUE='\033[1;34m'
H_GREEN='\033[1;32m'
H_YELLOW='\033[1;33m'
H_RED='\033[1;31m'
H_CYAN='\033[1;36m'

_info()    { local fmt=$1; shift; printf "${H_BLUE}%-10s${NC} ${fmt}\n" "${TAG_INFO}" "$@"; }
_success() { local fmt=$1; shift; printf "${H_GREEN}%-10s${NC} ${fmt}\n" "${TAG_SUCCESS}" "$@"; }
_warn()    { local fmt=$1; shift; printf "${H_YELLOW}%-10s${NC} ${fmt}\n" "${TAG_WARN}" "$@"; }
_error()   { local fmt=$1; shift; printf "${H_RED}%-10s${NC} ${fmt}\n" "${TAG_ERROR}" "$@"; exit 1; }

# ------------------------------
# 5. Check Helper
# ------------------------------
if command -v paru >/dev/null 2>&1; then AUR_HELPER=paru
elif command -v yay >/dev/null 2>&1; then AUR_HELPER=yay
else _error "${MSG[NO_HELPER]}"; fi

# ------------------------------
# 6. Introduction & Confirmation
# ------------------------------
if [[ "$SKIP_CONFIRM" == false ]]; then
  printf "\n${H_CYAN}%s${NC}\n" "${MSG[INTRO_HEADER]}"
  printf "%s\n" "${MSG[DESC_TITLE]}"
  printf "  %s\n" "${MSG[DESC_1]}"
  printf "  %s\n" "${MSG[DESC_2]}"
  printf "  %s\n" "${MSG[DESC_3]}"
  printf "  %s\n" "${MSG[DESC_4]}"
  printf "  %s\n" "${MSG[DESC_5]}"
  printf "  %s\n" "${MSG[DESC_6]}"
  printf "  %s\n" "${MSG[DESC_7]}"
  
  printf "\n${H_YELLOW}%s ${NC}" "${MSG[ASK_CONFIRM]}"
  read -r confirm || true
  case "$confirm" in
    [yY][eE][sS]|[yY]|"") ;; 
    *) printf "%s\n" "${MSG[ABORT]}"; exit 0 ;;
  esac
fi

# ------------------------------
# 7. Execution
# ------------------------------
_info "${MSG[HELPER_USE]}" "$AUR_HELPER"

# Keep Sudo Alive
if sudo -v; then
  while true; do sudo -n true; sleep 60; done 2>/dev/null &
  SUDO_PID=$!
  trap 'kill $SUDO_PID 2>/dev/null || true' EXIT
else
  _error "Sudo failed."
fi

# [1] Orphans (利用 mapfile 与 Bash 数组处理)
_info "${MSG[STEP_ORPHAN]}"
ORPHANS=$(pacman -Qtdq || true)
if [[ -n "$ORPHANS" ]]; then
  _warn "${MSG[ORPHAN_FOUND]}"
  mapfile -t ORPHAN_ARR <<< "$ORPHANS"
  $AUR_HELPER -Rns "${ORPHAN_ARR[@]}" --noconfirm
  _success "${MSG[ORPHAN_CLEAN]}"
else
  _success "${MSG[ORPHAN_NONE]}"
fi

# [2] Cache
_info "${MSG[STEP_CACHE]}"
$AUR_HELPER -Sc --noconfirm
_success "${MSG[CACHE_DONE]}"

# [3] Broken Downloads (化繁为简：find 一行流删除)
TARGET_DIR="/var/cache/pacman/pkg"
if [[ -d "$TARGET_DIR" ]]; then
  _info "${MSG[STEP_BROKEN]}"
  sudo find "$TARGET_DIR" -maxdepth 1 -type d -name "download-*" -exec rm -rf {} + 2>/dev/null || true
  _success "${MSG[BROKEN_DONE]}"
fi

# [4] Journal
_info "${MSG[STEP_LOG]}"
sudo journalctl --vacuum-time=2weeks >/dev/null 2>&1 || true
_success "${MSG[LOG_DONE]}"

# [5] Trash & Thumbnails
_info "${MSG[STEP_TRASH]}"
TRASH_DIR="$HOME/.local/share/Trash"
THUMB_DIR="$HOME/.cache/thumbnails"
CLIP_DIR="$HOME/.cache/shorinclip"

[[ -d "$TRASH_DIR" ]] && find "$TRASH_DIR" -mindepth 1 -delete 2>/dev/null || true
_success "${MSG[TRASH_DONE]}"

[[ -d "$THUMB_DIR" ]] && find "$THUMB_DIR" -type f -atime +30 -delete 2>/dev/null || true
_success "${MSG[THUMB_DONE]}"

[[ -d "$CLIP_DIR" ]] && find "$CLIP_DIR" -type f -atime +30 -delete 2>/dev/null || true
_success "${MSG[CLIP_DONE]}"

# [6] Flatpak
if command -v flatpak >/dev/null 2>&1; then
  _info "${MSG[STEP_FLATPAK]}"
  flatpak uninstall --unused -y >/dev/null 2>&1 || true
  _success "${MSG[FLATPAK_DONE]}"
fi

# [7] Screenshots & wf-recorder
_info "${MSG[STEP_MEDIA]}"
SCREENSHOTS_DIR="$HOME/Pictures/Screenshots"
RECORDS_DIR="$HOME/Videos/wf-recorder"

[[ -d "$SCREENSHOTS_DIR" ]] && find "$SCREENSHOTS_DIR" -mindepth 1 -delete 2>/dev/null || true
[[ -d "$RECORDS_DIR" ]] && find "$RECORDS_DIR" -mindepth 1 -delete 2>/dev/null || true
_success "${MSG[MEDIA_DONE]}"

# [8] Btrfs Snapshots & Backup Subvolumes
if command -v btrfs >/dev/null 2>&1 && findmnt -f -n -o FSTYPE / | grep -q btrfs; then
  # 8.1 Snapper
  if command -v snapper >/dev/null 2>&1; then
    _info "${MSG[STEP_SNAP]}"
    while IFS= read -r conf; do
      [[ -z "$conf" ]] && continue
      sudo snapper -c "$conf" cleanup number >/dev/null 2>&1 || true
      sudo snapper -c "$conf" cleanup timeline >/dev/null 2>&1 || true
    done < <(snapper list-configs 2>/dev/null | awk 'NR>2 {print $1}')
    _success "${MSG[SNAP_DONE]}"
  fi

  # 8.2 btrfs-assistant backups (解决 Root 权限读取挂载点问题)
  _info "${MSG[STEP_BTRFS_BA]}"
  BTRFS_ROOT_DEV=$(findmnt -n -o SOURCE / | cut -d'[' -f1)
  MNT_DIR=$(mktemp -d /tmp/btrfs_clean_XXXX)
  
  if sudo mount -t btrfs -o subvolid=5 "$BTRFS_ROOT_DEV" "$MNT_DIR" 2>/dev/null; then
    found_backups=0
    # 必须使用 sudo find 防止因为顶层目录权限过严导致查不出结果
    while IFS= read -r -d '' subvol_dir; do
      if sudo btrfs subvolume show "$subvol_dir" >/dev/null 2>&1; then
        sudo btrfs subvolume delete "$subvol_dir" >/dev/null 2>&1 || true
        printf "  Removed Backup Subvolume: %s\n" "$(basename "$subvol_dir")"
        found_backups=1
      fi
    done < <(sudo find "$MNT_DIR" -maxdepth 1 -type d -name "*_backup_20*" -print0 2>/dev/null)
    
    sudo umount "$MNT_DIR" || true
    rmdir "$MNT_DIR" || true
    
    if [[ $found_backups -eq 1 ]]; then
      _success "${MSG[BTRFS_BA_DONE]}"
    else
      _success "${MSG[BTRFS_BA_NONE]}"
    fi
  else
    rmdir "$MNT_DIR" || true
  fi
fi

printf "\n"
_success "${MSG[DONE]}"
